#include <SPI.h>
#include <Wire.h>
#include <OneWire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "DHT.h"
#define OLED_RESET 4
#define DHTPIN 8         // what pin we're connected to dht's data pin
#define DHTPIN_VDD 7     // what pin we're connected to dht's vcc pin
#define DHTPIN_GND 10     // what pin we're connected to dht's gnd pin
#define DHTTYPE DHT22 
OneWire  ds(12);
DHT dht(DHTPIN, DHTTYPE, 6);
Adafruit_SSD1306 display(OLED_RESET);
float celsius=25;
const  unsigned char   PROGMEM bitmaptt [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x06, 0x60, 0x00, 0x00, 0x04, 0x20, 0x00,
0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00,
0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x20, 0x00,
0x00, 0x04, 0x20, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00,
0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00,
0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x05, 0xA0, 0x00, 0x00, 0x0D, 0xB0, 0x00,
0x00, 0x1B, 0xD0, 0x00, 0x00, 0x17, 0xE8, 0x00, 0x00, 0x17, 0xE8, 0x00, 0x00, 0x17, 0xE8, 0x00,
0x00, 0x17, 0xE8, 0x00, 0x00, 0x1B, 0xD8, 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x07, 0xE0, 0x00 


};
const unsigned char PROGMEM water [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00,
0x00, 0x07, 0xE0, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x1F, 0xF8, 0x00,
0x00, 0x3B, 0xFC, 0x00, 0x00, 0x7B, 0xFE, 0x00, 0x00, 0x73, 0xFE, 0x00, 0x00, 0xE7, 0xFF, 0x00,
0x00, 0xE7, 0xFF, 0x00, 0x01, 0xC7, 0xFF, 0x80, 0x01, 0xCF, 0xFF, 0x80, 0x03, 0x8F, 0xFF, 0xC0,
0x03, 0x8F, 0xFF, 0xC0, 0x03, 0x0F, 0xFF, 0xC0, 0x07, 0x0F, 0xFF, 0xE0, 0x07, 0x1F, 0xFF, 0xE0,
0x07, 0x1F, 0xFF, 0xE0, 0x07, 0x1F, 0xFF, 0xE0, 0x07, 0x1F, 0xFF, 0xE0, 0x07, 0x1F, 0xFF, 0xE0,
0x03, 0x8F, 0xFF, 0xC0, 0x03, 0x8F, 0xFF, 0xC0, 0x01, 0xCF, 0xFF, 0x80, 0x01, 0xEF, 0xFF, 0x80,
0x00, 0xFF, 0xFF, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x1F, 0xF8, 0x00, 0x00, 0x03, 0xC0, 0x00
};
const unsigned char PROGMEM C [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x03, 0xF8, 0x1E,
0x07, 0xFC, 0x3F, 0x0E, 0x0C, 0x33, 0x1C, 0x04, 0x33, 0x18, 0x00, 0x33, 0x18, 0x00, 0x3F, 0x18,
0x00, 0x1E, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00, 0x1C, 0x04, 0x00, 0x0C, 0x04,
0x00, 0x0F, 0x0C, 0x00, 0x07, 0xF8, 0x00, 0x01, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};
const unsigned char PROGMEM Temperature_water_p [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00,
0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0x00,
0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xFF, 0x80,
0x00, 0x03, 0xFF, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00,
0x00, 0x03, 0xFF, 0x80, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00,
0x00, 0x03, 0xC0, 0x00, 0xFE, 0x07, 0xE0, 0x7F, 0xFF, 0xC7, 0xE3, 0xFF, 0x83, 0xC7, 0xE3, 0xC1,
0x00, 0x03, 0xC0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x3C, 0x3C, 0x1C,
0x3F, 0xFF, 0xFF, 0xFC, 0x07, 0xE7, 0xE7, 0xE0, 0x03, 0x81, 0x81, 0xC0, 0x00, 0x00, 0x00, 0x00

};

void setup()   {
   pinMode(DHTPIN_VDD, OUTPUT);
  pinMode(DHTPIN_GND, OUTPUT);  
  digitalWrite(DHTPIN_VDD, HIGH);
  digitalWrite(DHTPIN_GND, LOW);
  delay(100);
  Serial.begin(9600);
  display.begin(SSD1306_SWITCHCAPVCC, 0x78 >> 1);
  display.clearDisplay();
  dht.begin();
  delay(1000);
}


void loop() {
//  
//  
//  display.clearDisplay();
//  float t = dht.readTemperature();
//  display.drawBitmap(0, 16,  bitmaptt, 32, 32,1);
//   display.drawBitmap(105, 20,  C, 24, 24,1);
//  display.setTextSize(2);display.setTextColor(WHITE);display.setCursor(40,24);
//  display.print(t);
//  display.display();
//  delay(2000);
  display.clearDisplay();
////float t = dht.readTemperature();
  Temperature_water();
  display.drawBitmap(0, 16,  Temperature_water_p, 32, 32,1);
   display.drawBitmap(105, 20,  C, 24, 24,1);
  display.setTextSize(2);display.setTextColor(WHITE);display.setCursor(40,24);
  display.print(celsius);
  display.display();
  delay(1000);
//  display.clearDisplay();
//  float h = dht.readHumidity();
//  display.drawBitmap(0, 16,  water, 32, 32,1);
//  display.setTextSize(2);display.setTextColor(WHITE);display.setCursor(40,24);
//  display.print(h);display.print("%");
//  display.display();
//  delay(2000);
}

void Temperature_water() {
  byte i;
  byte present = 0;
  byte type_s;
  byte data[12];
  byte addr[8];
  
  
  if ( !ds.search(addr)) {
    ds.reset_search();
    delay(250);
    return;
  }
  if (OneWire::crc8(addr, 7) != addr[7]) {
      return;
  }
  Serial.println();
 
  // the first ROM byte indicates which chip
  switch (addr[0]) {
    case 0x10:
      type_s = 1;
      break;
    case 0x28:
      type_s = 0;
      break;
    case 0x22:
      type_s = 0;
      break;
    default:
      return;
  } 

  ds.reset();
  ds.select(addr);
  ds.write(0x44,1);         // start conversion, with parasite power on at the end
  
  delay(100);     // maybe 750ms is enough, maybe not
  // we might do a ds.depower() here, but the reset will take care of it.
  
  present = ds.reset();
  ds.select(addr);    
  ds.write(0xBE);         // Read Scratchpad
  for ( i = 0; i < 9; i++) {           // we need 9 bytes
    data[i] = ds.read();
  }
  unsigned int raw = (data[1] << 8) | data[0];
  if (type_s) {
    raw = raw << 3; // 9 bit resolution default
    if (data[7] == 0x10) {
      // count remain gives full 12 bit resolution
      raw = (raw & 0xFFF0) + 12 - data[6];
    }
  } else {
    byte cfg = (data[4] & 0x60);
    if (cfg == 0x00) raw = raw << 3;  // 9 bit resolution, 93.75 ms
    else if (cfg == 0x20) raw = raw << 2; // 10 bit res, 187.5 ms
    else if (cfg == 0x40) raw = raw << 1; // 11 bit res, 375 ms
    // default is 12 bit resolution, 750 ms conversion time
  }
  celsius = (float)raw / 16.0;
}








